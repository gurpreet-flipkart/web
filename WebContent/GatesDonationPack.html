<html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <div id="chart"></div>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    <script src="CustomToolTip.js"></script>
    <link rel="stylesheet" href="style.css">
    <div>
        <input type="radio" name="group" value="all">ALL</input>
        <input type="radio" name="group" value="year">YEAR</input>
        <input type="checkbox" name="top" value="top">TOP5</input>
    </div>
    <div id="vis"></div>
    <script>
        var width = 940;
        var height = 600;

        var tooltip = new CustomTooltip("gates_tooltip", 240);


        //locations the nodes will move towards depending on which view is currently being used
        var center = {
            x: width / 2,
            y: height / 2
        };
        //defining the regions.

        var year_centers = {
            "2008": {
                x: width / 3,
                y: height / 2
            },
            "2009": {
                x: width / 2,
                y: height / 2
            },
            "2010": {
                x: 2 * width / 3,
                y: height / 2
            }
        }


        //used when setting up force and moving around nodes
        //set too low gravity.
        var layout_gravity = -0.01;
        var damper = 0.1;
        var force = null;



        //root = exports ? this
        var data = [];
        var groups = ["low", "medium", "high"];
        var yearz = [2008, 2009, 2010];
        $(document).ready(function() {
            for (i = 1; i <= 255; i++) {
                data.push({
                    total_amount: parseInt(Math.random() * 1000000),
                    id: i,
                    grant_title: "Title" + parseInt(Math.random() * 100000),
                    organization: "Flipkart",
                    group: groups[parseInt(Math.random() * 3)],
                    start_year: yearz[parseInt(Math.random() * 3)]
                });
            }
            render(data);
        });
        var nodes = [];
        var radius_scale = null;
        var fill_color = null;
        //these will be set in create_nodes and 
        function render(data) {
            var vis = null;
            var circles = null;

            //nice looking colors - no reason to buck the trend 
            fill_color = d3.scale.ordinal()
                .domain(["low", "medium", "high"])
                .range(["#d62728", "#2ca02c", "#ffff00"]);

            //use the max total_amount in the data as the max in the scale 's domain
            var max_amount = d3.max(data, function(d) {
                return parseInt(d.total_amount);
            });
            console.log(max_amount);
            radius_scale = d3.scale.pow().exponent(0.5).domain([0, max_amount]).range([1, 20]);

            create_nodes();
            force = d3.layout.force()
                .nodes(nodes)
                .size([width, height]);
            create_vis();
            display_by_year();
            $('input[name=group]').on('change', function() {
                var choice = $('input[name=group]:checked').val();
                if (choice === 'all') {
                    display_group_all();
                } else if (choice === 'year') {
                    display_by_year();
                }
            });

            $('input[name=top]').on('click', function() {
                var choice = $('input[name=top]:checked').length == 1 ? true : false;
                console.log(choice);
                if (choice) {
                    highlightTop(5, 0.1);
                } else {
                    highlightTop(5, 1.0);
                }
            });
        }
        //create node objects from original data# that will serve as the data behind each# bubble in the vis, then add each node# to@ nodes to be           //used later
        function create_nodes() {
            data.forEach(function(d) {
                var node = {
                    id: d.id,
                    radius: radius_scale(parseInt(d.total_amount)),
                    value: d.total_amount,
                    name: d.grant_title,
                    org: d.organization,
                    group: d.group,
                    year: d.start_year,
                    x: Math.random() * 900,
                    y: Math.random() * 800
                };
                nodes.push(node);
            });
            nodes.sort(function(a, b) {
                return b.value - a.value;
            });
            console.log(nodes);
        }


        function highlightTop(N, opacity) {
            //find ids of  top5 circles
            var idz = [];
            for (i = 0; i < N; i++) {
                idz.push(nodes[i].id);
            }
            console.log(idz);
            var topNCircles = vis.selectAll("circle").filter(function(d) {

                if ($.inArray(d.id, idz) != -1) {
                    console.log(d.id);
                    return false;
                }
                return true;
            });
            topNCircles.transition().duration(1500).attr("opacity", opacity);
        }


        //# create svg at# vis and then# create circle representation for each node
        function create_vis() {
            vis = d3.select("#vis").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("id", "svg_vis");

            circles = vis.selectAll("circle")
                .data(nodes, function(d) {
                    return d.id;
                });

            //# radius will be set to 0 initially.#see transition below
            circles.enter().append("circle")
                .attr("r", 0)
                .attr("fill", function(d) {
                    return fill_color(d.group);
                })
                .attr("stroke-width", 1)
                .attr("stroke", function(d) {
                    return d3.rgb(fill_color(d.group)).darker();
                })
                .attr("id", function(d) {
                    return "bubble_" + d.id;
                })
                .on("mouseover", function(d, i) {
                    show_details(d, i, this)
                })
                .on("mouseout", function(d, i) {
                    return hide_details(d, i, this)
                });

            circles.transition().duration(2000).attr("r", function(d) {
                return d.radius;
            });

        }

        /* Charge function that is called for each node.
           Charge is proportional to the diameter of the
           circle (which is stored in the radius attribute
           of the circle's associated data.
           This is done to allow for accurate collision 
           detection with nodes of different sizes.
           Charge is negative because we want nodes to 
           repel.
           Dividing by 8 scales down the charge to be
           appropriate for the visualization dimensions.*/

        var charge = function(d) {
            return -Math.pow(d.radius, 2.0) / 8;
        }




        // # Sets up force layout to display all nodes in one circle.
        function display_group_all() {
            force.gravity(layout_gravity)
                .charge(charge)
                .friction(0.9)
                .on("tick", function(e) {
                    circles.each(move_towards_center(e.alpha))
                        .attr("cx", function(d) {
                            return d.x;
                        })
                        .attr("cy", function(d) {
                            return d.y;
                        });
                });
            force.start();

            hide_years();
        }


        //# Moves all circles towards the @center of the visualization
        function move_towards_center(alpha) {
            return function(d) {
                d.x = d.x + (center.x - d.x) * (damper + 0.02) * alpha;
                d.y = d.y + (center.y - d.y) * (damper + 0.02) * alpha;
            }
        }



        //# sets the display of bubbles to be separated
        //# into each year. Does this by calling move_towards_year
        function display_by_year() {
            force.gravity(layout_gravity)
                .charge(this.charge)
                .friction(0.9)
                .on("tick", function(e) {
                    circles.each(move_towards_year(e.alpha))
                        .attr("cx", function(d) {
                            return d.x;
                        })
                        .attr("cy", function(d) {
                            return d.y;
                        });
                });
            force.start();
            display_years();
        }


        //# move all circles to their associated @year_centers 
        function move_towards_year(alpha) {
            return function(d) {
                target = year_centers[d.year]
                d.x = d.x + (target.x - d.x) * (damper + 0.02) * alpha * 1.1;
                d.y = d.y + (target.y - d.y) * (damper + 0.02) * alpha * 1.1;
            }
        }



        // # Method to display year titles
        function display_years() {
            var years_x = {
                "2008": 160,
                "2009": width / 2,
                "2010": width - 160
            };
            var years_data = d3.keys(years_x);
            var years = vis.selectAll(".years")
                .data(years_data);

            years.enter().append("text")
                .attr("class", "years")
                .attr("x", function(d) {
                    return years_x[d];
                })
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .text(function(d) {
                    return d;
                });
        }
        //# Method to hide year titiles
        function hide_years() {
            years = vis.selectAll(".years").remove();
        }


        function show_details(data, i, element) {
            //console.log(data);
            /*d3.select("#vis>svg").append("g").attr("transform", "translate(" + $(element).attr("cx") + "," + $(element).attr("cy") + ")").selectAll('circle').data([data]).enter().append('circle')
                .attr("r", function(s) {
                    return s.radius + 5;
                })
                .attr("opacity",0.1)
                .attr("stroke-width", 2)
                .attr("stroke", function(d) {
                    return d3.rgb(fill_color(d.group)).darker();
                });*/
            d3.select(element).attr("stroke", "black");
            d3.select(element).attr("stroke-width", 2)
            content = "<span class=\"name\">Title:</span><span class=\"value\">" + data.name + "</span><br/>"
            content += "<span class=\"name\">Amount:</span><span class=\"value\">" + data.value + "</span><br/>"
            content += "<span class=\"name\">Year:</span><span class=\"value\">" + data.year + "</span>";
            tooltip.showTooltip(content, d3.event);
        }

        function hide_details(data, i, element) {
            //d3.selectAll("#vis>svg>g").remove();
            d3.select(element).attr("stroke-width", 1);
            d3.select(element).attr("stroke", function(d) {
                return d3.rgb(fill_color(d.group)).darker();
            });
            tooltip.hideTooltip();
        }
    </script>

</body>

</html>